import { logger } from '../utils/logger.js';
import { writeText, writeJson } from '../utils/file-utils.js';

/**
 * Generate a Markdown report from aggregated scores
 * @param {Object} aggregation - Aggregated scores
 * @param {Object} tiers - Tier information
 * @param {Object} stats - Statistics
 * @param {Object} options - Report options
 * @returns {string} Markdown report content
 */
export function generateMarkdownReport(aggregation, tiers, stats, options = {}) {
  const { title = 'Photo Analysis Report', theme = '', competitionName = '', failedPhotos = [] } = options;

  let report = `# ${title}\n\n`;

  if (competitionName) {
    report += `**Competition**: ${competitionName}\n`;
  }
  if (theme) {
    report += `**Theme**: ${theme}\n`;
  }

  report += `**Generated**: ${new Date(aggregation.timestamp).toLocaleString()}\n`;
  report += `**Total Photos Analyzed**: ${aggregation.total_photos}\n`;
  
  // Add failed photos count (FR-2.3)
  if (failedPhotos && failedPhotos.length > 0) {
    report += `**Failed Photos**: ${failedPhotos.length}\n`;
  }
  report += '\n';

  // Add summary statistics
  report += `## Summary Statistics\n\n`;
  report += `| Metric | Value |\n`;
  report += `|--------|-------|\n`;
  report += `| Average Score | ${stats.average}/10 |\n`;
  report += `| Median Score | ${stats.median}/10 |\n`;
  report += `| Score Range | ${stats.min.toFixed(1)} - ${stats.max.toFixed(1)} |\n`;
  report += `| Std. Deviation | ${stats.std_dev.toFixed(2)} |\n\n`;

  // Add tier summary
  if (tiers && tiers.summary) {
    report += `## Results by Tier\n\n`;
    Object.entries(tiers.summary).forEach(([tierKey, tierData]) => {
      const tierLabel = tiers.tiers[tierKey]?.[0] ? 'Unknown' : tierKey.replace(/_/g, ' ').toUpperCase();
      report += `- **${tierLabel}**: ${tierData.count} photos (${tierData.percentage}%)\n`;
    });
    report += '\n';
  }

  // Add top recommendations
  report += `## Top Recommendations\n\n`;

  const topPhotos = aggregation.photos.slice(0, Math.min(10, aggregation.photos.length));
  topPhotos.forEach((photo, index) => {
    const photoName = photo.photo.split('/').pop();
    report += `### ${index + 1}. ${photoName}\n`;
    report += `**Overall Score**: ${photo.overall_score || 'N/A'}/10 | **Rank**: #${photo.rank}\n\n`;

    if (photo.individual_scores && Object.keys(photo.individual_scores).length > 0) {
      report += `**Criterion Scores**:\n`;
      Object.entries(photo.individual_scores).forEach(([criterion, data]) => {
        const bar = generateScoreBar(data.score);
        report += `- ${criterion}: ${data.score}/10 ${bar}\n`;
      });
      report += '\n';
    }
  });

  // Add detailed analysis for all photos
  report += `## Full Photo Rankings\n\n`;
  report += `| Rank | Photo | Score | Recommendation |\n`;
  report += `|------|-------|-------|----------------|\n`;

  aggregation.photos.forEach((photo) => {
    const photoName = photo.photo.split('/').pop();
    const score = photo.overall_score || 'N/A';
    const recommendation = photo.summary?.recommendation || '—';
    report += `| ${photo.rank} | ${photoName} | ${score} | ${recommendation} |\n`;
  });

  // Add failed photos section (FR-2.3)
  if (failedPhotos && failedPhotos.length > 0) {
    report += `\n## Failed Photos\n\n`;
    report += `The following photos could not be analyzed:\n\n`;
    report += `| Photo | Error Type | Reason | Suggested Action |\n`;
    report += `|-------|------------|--------|------------------|\n`;
    
    failedPhotos.forEach((failed) => {
      const photoName = failed.photo;
      const errorType = failed.type || 'unknown';
      const reason = failed.reason || 'Unknown error';
      const action = failed.action || 'Check file and try again';
      report += `| ${photoName} | ${errorType} | ${reason} | ${action} |\n`;
    });
    report += '\n';
  }

  report += '\n---\n';
  report += `*Report generated by Photo Open Call Analyzer*\n`;

  return report;
}

/**
 * Save report to file
 * @param {string} filePath - Path to save report
 * @param {string} content - Report content
 */
export function saveMarkdownReport(filePath, content) {
  writeText(filePath, content);
  logger.success(`Report saved to: ${filePath}`);
}

/**
 * Generate JSON export of results
 * @param {Object} aggregation - Aggregated scores
 * @param {Object} tiers - Tier information
 * @param {Object} stats - Statistics
 * @param {Object} options - Export options
 * @returns {Object} JSON-serializable report data
 */
export function generateJsonReport(aggregation, tiers, stats, options = {}) {
  const { failedPhotos = [] } = options;
  
  const report = {
    metadata: {
      generated: new Date().toISOString(),
      total_photos: aggregation.total_photos,
      failed_photos: failedPhotos.length,
      report_version: '1.0',
    },
    statistics: stats,
    tiers: tiers,
    ranking: aggregation.photos.map((photo) => ({
      rank: photo.rank,
      photo: photo.photo,
      overall_score: photo.overall_score,
      individual_scores: photo.individual_scores,
      recommendation: photo.summary?.recommendation,
    })),
  };
  
  // Add failed photos if any (FR-2.3)
  if (failedPhotos.length > 0) {
    report.failed_photos = failedPhotos;
  }
  
  return report;
}

/**
 * Generate CSV export of results
 * @param {Object} aggregation - Aggregated scores
 * @returns {string} CSV content
 */
export function generateCsvReport(aggregation) {
  let csv = 'Rank,Photo,Overall Score,Recommendation\n';

  aggregation.photos.forEach((photo) => {
    const photoName = photo.photo.split('/').pop();
    const score = photo.overall_score || '';
    const recommendation = photo.summary?.recommendation || '';

    // Escape CSV values
    const escapedName = `"${photoName.replace(/"/g, '""')}"`;
    const escapedRecommendation = `"${recommendation.replace(/"/g, '""')}"`;

    csv += `${photo.rank},${escapedName},${score},${escapedRecommendation}\n`;
  });

  return csv;
}

/**
 * Generate a text-based score bar for visualization
 * @param {number} score - Score from 0-10
 * @returns {string} ASCII bar representation
 */
function generateScoreBar(score) {
  const filled = Math.round(score / 2);
  const empty = 5 - filled;
  return '█'.repeat(filled) + '░'.repeat(empty);
}

/**
 * Export reports to disk
 * @param {string} outputDir - Output directory
 * @param {Object} aggregation - Aggregated scores
 * @param {Object} tiers - Tier information
 * @param {Object} stats - Statistics
 * @param {Object} options - Export options including failedPhotos
 */
export function exportReports(outputDir, aggregation, tiers, stats, options = {}) {
  logger.info(`Exporting reports to: ${outputDir}`);

  const { formats = ['markdown', 'json', 'csv'], basename = 'analysis-results', failedPhotos = [] } = options;

  if (formats.includes('markdown')) {
    const markdownContent = generateMarkdownReport(aggregation, tiers, stats, { ...options, failedPhotos });
    const mdPath = `${outputDir}/${basename}.md`;
    saveMarkdownReport(mdPath, markdownContent);
  }

  if (formats.includes('json')) {
    const jsonContent = generateJsonReport(aggregation, tiers, stats, { failedPhotos });
    const jsonPath = `${outputDir}/${basename}.json`;
    writeJson(jsonPath, jsonContent);
    logger.success(`JSON report saved to: ${jsonPath}`);
  }

  if (formats.includes('csv')) {
    const csvContent = generateCsvReport(aggregation);
    const csvPath = `${outputDir}/${basename}.csv`;
    writeText(csvPath, csvContent);
    logger.success(`CSV report saved to: ${csvPath}`);
  }

  logger.success('All reports exported successfully');
}
