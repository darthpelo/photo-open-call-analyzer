import { logger } from '../utils/logger.js';
import { writeText, writeJson } from '../utils/file-utils.js';

/**
 * Generate a Markdown report from aggregated scores
 * @param {Object} aggregation - Aggregated scores
 * @param {Object} tiers - Tier information
 * @param {Object} stats - Statistics
 * @param {Object} options - Report options
 * @returns {string} Markdown report content
 */
export function generateMarkdownReport(aggregation, tiers, stats, options = {}) {
  const { title = 'Photo Analysis Report', theme = '', competitionName = '', failedPhotos = [] } = options;

  let report = `# ${title}\n\n`;

  if (competitionName) {
    report += `**Competition**: ${competitionName}\n`;
  }
  if (theme) {
    report += `**Theme**: ${theme}\n`;
  }

  report += `**Generated**: ${new Date(aggregation.timestamp).toLocaleString()}\n`;
  report += `**Total Photos Analyzed**: ${aggregation.total_photos}\n`;
  
  // Add failed photos count (FR-2.3)
  if (failedPhotos && failedPhotos.length > 0) {
    report += `**Failed Photos**: ${failedPhotos.length}\n`;
  }
  report += '\n';

  // Add summary statistics
  report += `## Summary Statistics\n\n`;
  report += `| Metric | Value |\n`;
  report += `|--------|-------|\n`;
  report += `| Average Score | ${stats.average}/10 |\n`;
  report += `| Median Score | ${stats.median}/10 |\n`;
  report += `| Score Range | ${stats.min.toFixed(1)} - ${stats.max.toFixed(1)} |\n`;
  report += `| Std. Deviation | ${stats.std_dev.toFixed(2)} |\n\n`;

  // Add tier summary
  if (tiers && tiers.summary) {
    report += `## Results by Tier\n\n`;
    Object.entries(tiers.summary).forEach(([tierKey, tierData]) => {
      const tierLabel = tiers.tiers[tierKey]?.[0] ? 'Unknown' : tierKey.replace(/_/g, ' ').toUpperCase();
      report += `- **${tierLabel}**: ${tierData.count} photos (${tierData.percentage}%)\n`;
    });
    report += '\n';
  }

  // Add top recommendations
  report += `## Top Recommendations\n\n`;

  const topPhotos = aggregation.photos.slice(0, Math.min(10, aggregation.photos.length));
  topPhotos.forEach((photo, index) => {
    const photoName = photo.photo.split('/').pop();
    report += `### ${index + 1}. ${photoName}\n`;
    report += `**Overall Score**: ${photo.overall_score || 'N/A'}/10 | **Rank**: #${photo.rank}\n\n`;

    if (photo.individual_scores && Object.keys(photo.individual_scores).length > 0) {
      report += `**Criterion Scores**:\n`;
      Object.entries(photo.individual_scores).forEach(([criterion, data]) => {
        const bar = generateScoreBar(data.score);
        report += `- ${criterion}: ${data.score}/10 ${bar}\n`;
      });
      report += '\n';
    }
  });

  // Add detailed analysis for all photos
  report += `## Full Photo Rankings\n\n`;
  report += `| Rank | Photo | Score | Recommendation |\n`;
  report += `|------|-------|-------|----------------|\n`;

  aggregation.photos.forEach((photo) => {
    const photoName = photo.photo.split('/').pop();
    const score = photo.overall_score || 'N/A';
    const recommendation = photo.summary?.recommendation || 'â€”';
    report += `| ${photo.rank} | ${photoName} | ${score} | ${recommendation} |\n`;
  });

  // Add failed photos section (FR-2.3)
  if (failedPhotos && failedPhotos.length > 0) {
    report += `\n## Failed Photos\n\n`;
    report += `The following photos could not be analyzed:\n\n`;
    report += `| Photo | Error Type | Reason | Suggested Action |\n`;
    report += `|-------|------------|--------|------------------|\n`;
    
    failedPhotos.forEach((failed) => {
      const photoName = failed.photo;
      const errorType = failed.type || 'unknown';
      const reason = failed.reason || 'Unknown error';
      const action = failed.action || 'Check file and try again';
      report += `| ${photoName} | ${errorType} | ${reason} | ${action} |\n`;
    });
    report += '\n';
  }

  report += '\n---\n';
  report += `*Report generated by Photo Open Call Analyzer*\n`;

  return report;
}

/**
 * Save report to file
 * @param {string} filePath - Path to save report
 * @param {string} content - Report content
 */
export function saveMarkdownReport(filePath, content) {
  writeText(filePath, content);
  logger.success(`Report saved to: ${filePath}`);
}

/**
 * Generate JSON export of results
 * @param {Object} aggregation - Aggregated scores
 * @param {Object} tiers - Tier information
 * @param {Object} stats - Statistics
 * @param {Object} options - Export options
 * @returns {Object} JSON-serializable report data
 */
export function generateJsonReport(aggregation, tiers, stats, options = {}) {
  const { failedPhotos = [] } = options;
  
  const report = {
    metadata: {
      generated: new Date().toISOString(),
      total_photos: aggregation.total_photos,
      failed_photos: failedPhotos.length,
      report_version: '1.0',
    },
    statistics: stats,
    tiers: tiers,
    ranking: aggregation.photos.map((photo) => ({
      rank: photo.rank,
      photo: photo.photo,
      overall_score: photo.overall_score,
      individual_scores: photo.individual_scores,
      recommendation: photo.summary?.recommendation,
    })),
  };
  
  // Add failed photos if any (FR-2.3)
  if (failedPhotos.length > 0) {
    report.failed_photos = failedPhotos;
  }
  
  return report;
}

/**
 * Generate Markdown report with Smart Tiering sections
 * Separates photos into confidence tier sections with detailed analysis
 * 
 * @param {Object} smartTiers - Output from integrateSmartTiering()
 * @param {Object} stats - Statistics from generateStatistics()
 * @param {Object} options - Report options
 * @returns {string} Markdown report content organized by tiers
 */
export function generateTierMarkdownReport(smartTiers, stats, options = {}) {
  const { title = 'Smart Tiering Report', theme = '', competitionName = '' } = options;

  let report = `# ${title}\n\n`;

  if (competitionName) {
    report += `**Competition**: ${competitionName}\n`;
  }
  if (theme) {
    report += `**Theme**: ${theme}\n`;
  }

  report += `**Generated**: ${new Date().toLocaleString()}\n`;
  report += `**Total Photos**: ${smartTiers.summary.total}\n\n`;

  // Tier summary
  report += `## Tier Summary\n\n`;
  report += `| Tier | Count | Percentage | Threshold |\n`;
  report += `|------|-------|------------|-----------|\n`;
  report += `| ðŸŸ¢ Tier 1 (Strong) | ${smartTiers.summary.tier1_count} | ${Math.round((smartTiers.summary.tier1_count / smartTiers.summary.total) * 100)}% | > ${smartTiers.summary.high_threshold} |\n`;
  report += `| ðŸŸ¡ Tier 2 (Good) | ${smartTiers.summary.tier2_count} | ${Math.round((smartTiers.summary.tier2_count / smartTiers.summary.total) * 100)}% | > ${smartTiers.summary.medium_threshold} |\n`;
  report += `| ðŸŸ  Tier 3 (Borderline) | ${smartTiers.summary.tier3_count} | ${Math.round((smartTiers.summary.tier3_count / smartTiers.summary.total) * 100)}% | â‰¤ ${smartTiers.summary.medium_threshold} |\n\n`;

  // Statistics
  report += `## Statistics\n\n`;
  report += `| Metric | Value |\n`;
  report += `|--------|-------|\n`;
  report += `| Average Score | ${stats.average}/10 |\n`;
  report += `| Median Score | ${stats.median}/10 |\n`;
  report += `| Score Range | ${stats.min.toFixed(1)} - ${stats.max.toFixed(1)} |\n`;
  report += `| Std. Deviation | ${stats.std_dev?.toFixed(2) || 'N/A'} |\n\n`;

  // Tier 1 photos
  if (smartTiers.tier1 && smartTiers.tier1.length > 0) {
    report += `## ðŸŸ¢ Tier 1: Strong Submissions (${smartTiers.tier1.length} photos)\n\n`;
    report += `These photos scored above **${smartTiers.summary.high_threshold}** and are recommended for submission.\n\n`;
    
    smartTiers.tier1.forEach((photo, idx) => {
      const displayName = photo.filename || photo.file || photo.name || 'unknown';
      report += `### ${idx + 1}. ${displayName}\n`;
      report += `**Score**: ${photo.score.toFixed(1)}/10 | **Status**: âœ… Ready for submission\n\n`;
    });
  }

  // Tier 2 photos
  if (smartTiers.tier2 && smartTiers.tier2.length > 0) {
    report += `## ðŸŸ¡ Tier 2: Good Submissions (${smartTiers.tier2.length} photos)\n\n`;
    report += `These photos scored between **${smartTiers.summary.medium_threshold}** and **${smartTiers.summary.high_threshold}** and are good candidates.\n\n`;
    
    smartTiers.tier2.forEach((photo, idx) => {
      const displayName = photo.filename || photo.file || photo.name || 'unknown';
      report += `### ${idx + 1}. ${displayName}\n`;
      report += `**Score**: ${photo.score.toFixed(1)}/10 | **Status**: ðŸ‘ Good candidate\n\n`;
    });
  }

  // Tier 3 photos
  if (smartTiers.tier3 && smartTiers.tier3.length > 0) {
    report += `## ðŸŸ  Tier 3: Borderline Submissions (${smartTiers.tier3.length} photos)\n\n`;
    report += `These photos scored at or below **${smartTiers.summary.medium_threshold}** and may need revision.\n\n`;
    
    smartTiers.tier3.forEach((photo, idx) => {
      const displayName = photo.filename || photo.file || photo.name || 'unknown';
      report += `### ${idx + 1}. ${displayName}\n`;
      report += `**Score**: ${photo.score.toFixed(1)}/10 | **Status**: âš ï¸ Review recommended\n\n`;
    });
  }

  report += `---\n`;
  report += `*Report generated by Photo Open Call Analyzer - Smart Tiering Module*\n`;

  return report;
}

/**
 * Generate JSON report with Smart Tiering structure
 * 
 * @param {Object} smartTiers - Output from integrateSmartTiering()
 * @param {Object} stats - Statistics from generateStatistics()
 * @returns {Object} JSON structure with tier breakdown
 */
export function generateTierJsonReport(smartTiers, stats) {
  return {
    metadata: {
      generated: new Date().toISOString(),
      total_photos: smartTiers.summary.total,
      report_version: '2.0',
    },
    summary: smartTiers.summary,
    statistics: stats,
    tiers: {
      tier1: (smartTiers.tier1 || []).map(p => ({
        filename: p.filename || p.name,
        score: p.score,
        tier: 'tier1',
        label: 'ðŸŸ¢ Strong'
      })),
      tier2: (smartTiers.tier2 || []).map(p => ({
        filename: p.filename || p.name,
        score: p.score,
        tier: 'tier2',
        label: 'ðŸŸ¡ Good'
      })),
      tier3: (smartTiers.tier3 || []).map(p => ({
        filename: p.filename || p.name,
        score: p.score,
        tier: 'tier3',
        label: 'ðŸŸ  Borderline'
      }))
    }
  };
}

/**
 * Generate CSV report with Smart Tiering columns
 * 
 * @param {Object} smartTiers - Output from integrateSmartTiering()
 * @returns {string} CSV content with tier assignments
 */
export function generateTierCsvReport(smartTiers) {
  let csv = 'Filename,Score,Tier,Label,Recommendation\n';

  const tierData = [
    { tier: smartTiers.tier1, tierLabel: 'Tier1', displayLabel: 'ðŸŸ¢ Strong', rec: 'Submit' },
    { tier: smartTiers.tier2, tierLabel: 'Tier2', displayLabel: 'ðŸŸ¡ Good', rec: 'Consider' },
    { tier: smartTiers.tier3, tierLabel: 'Tier3', displayLabel: 'ðŸŸ  Borderline', rec: 'Review' }
  ];

  tierData.forEach(({ tier, tierLabel, displayLabel, rec }) => {
    if (tier && Array.isArray(tier)) {
      tier.forEach(photo => {
        const filename = photo.filename || photo.name || 'unknown';
        const score = photo.score.toFixed(2);
        const escapedFilename = `"${filename.replace(/"/g, '""')}"`;
        csv += `${escapedFilename},${score},${tierLabel},${displayLabel},${rec}\n`;
      });
    }
  });

  return csv;
}

/**
 * Generate CSV export of results
 * @param {Object} aggregation - Aggregated scores
 * @returns {string} CSV content
 */
export function generateCsvReport(aggregation) {
  let csv = 'Rank,Photo,Overall Score,Recommendation\n';

  aggregation.photos.forEach((photo) => {
    const photoName = photo.photo.split('/').pop();
    const score = photo.overall_score || '';
    const recommendation = photo.summary?.recommendation || '';

    // Escape CSV values
    const escapedName = `"${photoName.replace(/"/g, '""')}"`;
    const escapedRecommendation = `"${recommendation.replace(/"/g, '""')}"`;

    csv += `${photo.rank},${escapedName},${score},${escapedRecommendation}\n`;
  });

  return csv;
}

/**
 * Generate a text-based score bar for visualization
 * @param {number} score - Score from 0-10
 * @returns {string} ASCII bar representation
 */
function generateScoreBar(score) {
  const filled = Math.round(score / 2);
  const empty = 5 - filled;
  return 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(empty);
}

/**
 * Export reports to disk
 * @param {string} outputDir - Output directory
 * @param {Object} aggregation - Aggregated scores
 * @param {Object} tiers - Tier information
 * @param {Object} stats - Statistics
 * @param {Object} options - Export options including failedPhotos
 */
export function exportReports(outputDir, aggregation, tiers, stats, options = {}) {
  logger.info(`Exporting reports to: ${outputDir}`);

  const { formats = ['markdown', 'json', 'csv'], basename = 'analysis-results', smartTiers = null, failedPhotos = [] } = options;

  if (formats.includes('markdown')) {
    const markdownContent = generateMarkdownReport(aggregation, tiers, stats, { ...options, failedPhotos });
    const mdPath = `${outputDir}/${basename}.md`;
    saveMarkdownReport(mdPath, markdownContent);

    // Also export tier-specific markdown if smartTiers provided
    if (smartTiers) {
      const tierMarkdownContent = generateTierMarkdownReport(smartTiers, stats, options);
      const tierMdPath = `${outputDir}/${basename}-tiers.md`;
      saveMarkdownReport(tierMdPath, tierMarkdownContent);
    }
  }

  if (formats.includes('json')) {
    const jsonContent = generateJsonReport(aggregation, tiers, stats, { failedPhotos });
    const jsonPath = `${outputDir}/${basename}.json`;
    writeJson(jsonPath, jsonContent);
    logger.success(`JSON report saved to: ${jsonPath}`);

    // Also export tier-specific JSON if smartTiers provided
    if (smartTiers) {
      const tierJsonContent = generateTierJsonReport(smartTiers, stats);
      const tierJsonPath = `${outputDir}/${basename}-tiers.json`;
      writeJson(tierJsonPath, tierJsonContent);
      logger.success(`Tier JSON report saved to: ${tierJsonPath}`);
    }
  }

  if (formats.includes('csv')) {
    const csvContent = generateCsvReport(aggregation);
    const csvPath = `${outputDir}/${basename}.csv`;
    writeText(csvPath, csvContent);
    logger.success(`CSV report saved to: ${csvPath}`);

    // Also export tier-specific CSV if smartTiers provided
    if (smartTiers) {
      const tierCsvContent = generateTierCsvReport(smartTiers);
      const tierCsvPath = `${outputDir}/${basename}-tiers.csv`;
      writeText(tierCsvPath, tierCsvContent);
      logger.success(`Tier CSV report saved to: ${tierCsvPath}`);
    }
  }

  logger.success('All reports exported successfully');
}
